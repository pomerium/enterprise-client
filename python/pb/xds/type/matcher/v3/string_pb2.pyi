"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys
import xds.type.matcher.v3.regex_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class StringMatcher(google.protobuf.message.Message):
    """[#protodoc-title: String matcher]

    Specifies the way to match a string.
    [#next-free-field: 8]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXACT_FIELD_NUMBER: builtins.int
    PREFIX_FIELD_NUMBER: builtins.int
    SUFFIX_FIELD_NUMBER: builtins.int
    SAFE_REGEX_FIELD_NUMBER: builtins.int
    CONTAINS_FIELD_NUMBER: builtins.int
    IGNORE_CASE_FIELD_NUMBER: builtins.int
    exact: builtins.str
    """The input string must match exactly the string specified here.

    Examples:

    * *abc* only matches the value *abc*.
    """
    prefix: builtins.str
    """The input string must have the prefix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *abc.xyz*
    """
    suffix: builtins.str
    """The input string must have the suffix specified here.
    Note: empty prefix is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *xyz.abc*
    """
    @property
    def safe_regex(self) -> xds.type.matcher.v3.regex_pb2.RegexMatcher:
        """The input string must match the regular expression specified here."""
    contains: builtins.str
    """The input string must have the substring specified here.
    Note: empty contains match is not allowed, please use regex instead.

    Examples:

    * *abc* matches the value *xyz.abc.def*
    """
    ignore_case: builtins.bool
    """If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no
    effect for the safe_regex match.
    For example, the matcher *data* will match both input string *Data* and *data* if set to true.
    """
    def __init__(
        self,
        *,
        exact: builtins.str = ...,
        prefix: builtins.str = ...,
        suffix: builtins.str = ...,
        safe_regex: xds.type.matcher.v3.regex_pb2.RegexMatcher | None = ...,
        contains: builtins.str = ...,
        ignore_case: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["contains", b"contains", "exact", b"exact", "match_pattern", b"match_pattern", "prefix", b"prefix", "safe_regex", b"safe_regex", "suffix", b"suffix"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["contains", b"contains", "exact", b"exact", "ignore_case", b"ignore_case", "match_pattern", b"match_pattern", "prefix", b"prefix", "safe_regex", b"safe_regex", "suffix", b"suffix"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["match_pattern", b"match_pattern"]) -> typing_extensions.Literal["exact", "prefix", "suffix", "safe_regex", "contains"] | None: ...

global___StringMatcher = StringMatcher

class ListStringMatcher(google.protobuf.message.Message):
    """Specifies a list of ways to match a string."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATTERNS_FIELD_NUMBER: builtins.int
    @property
    def patterns(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StringMatcher]: ...
    def __init__(
        self,
        *,
        patterns: collections.abc.Iterable[global___StringMatcher] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["patterns", b"patterns"]) -> None: ...

global___ListStringMatcher = ListStringMatcher
